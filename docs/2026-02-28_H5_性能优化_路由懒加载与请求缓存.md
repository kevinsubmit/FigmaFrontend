# 2026-02-28 H5 性能优化记录（路由懒加载 / 请求缓存 / 列表惰性渲染）

## 一、目标
- 扫描并优化 H5 前端的代码结构、网络层会话与请求性能、资源 URL 基址处理、列表渲染性能。
- 在不改业务接口的前提下，减少首屏包体与重复请求，降低滚动场景 CPU/布局开销。

## 二、核心改动

### 1) 路由级代码分割（首屏性能）
- 文件：`frontend/src/App.tsx`
- 改动：
  - 页面组件改为 `React.lazy + Suspense` 按路由懒加载。
  - 增加统一路由级 loading fallback。
- 效果：
  - 减少首页首次加载时一次性解析/执行的 JS 体积。
  - 页面切换按需加载，降低首屏阻塞。

### 2) fetch 网络层（api/client.ts）优化
- 文件：`frontend/src/api/client.ts`
- 改动：
  - 增加 GET 请求短缓存（TTL，默认 10s）。
  - 增加并发请求去重（in-flight dedupe）。
  - 非 GET 写请求成功后清理 GET 缓存，避免脏数据。
  - token `set/remove` 时清缓存，避免跨账号缓存污染。
  - 响应解析增强：兼容 204/205、非 JSON 返回体。
- 效果：
  - 减少重复 GET 请求与同屏并发重复请求。
  - 提升列表页/详情页重复进入时响应速度。

### 3) axios 网络层（lib/api.ts）优化
- 文件：`frontend/src/lib/api.ts`
- 改动：
  - 对 `apiClient.get` 增加统一 GET 缓存 + 并发去重。
  - 支持可选参数：`skipCache / dedupe / cacheTTL / cacheKey`。
  - 401 强制重登时清缓存；非 GET 成功后清缓存。
  - token 变化时清缓存（请求拦截器内处理）。
- 效果：
  - `services/*` 目录下 axios 调用路径也获得相同的请求去重与短缓存收益。

### 4) 资源 URL 基址统一与缓存
- 文件：`frontend/src/utils/assetUrl.ts`
- 改动：
  - `resolveAssetUrl` 增加解析结果缓存（Map + 容量上限淘汰）。
  - 新增 `getApiBaseUrl()`，统一网络层与资源层基址来源。
  - 保留/增强版本参数拼接与持久资源路径识别。
- 效果：
  - 避免多处重复手工拼接 `${VITE_API_BASE_URL}${path}`。
  - 降低高频图片 URL 解析开销与分散实现风险。

### 5) 列表惰性渲染与图片加载优化
- 文件：
  - `frontend/src/components/Home.tsx`
  - `frontend/src/components/Services.tsx`
  - `frontend/src/components/Deals.tsx`
  - `frontend/src/components/MyFavorites.tsx`
  - `frontend/src/components/StoreDetails.tsx`
  - `frontend/src/components/PinDetail.tsx`
  - `frontend/src/components/Profile.tsx`
  - `frontend/src/components/EditProfile.tsx`
- 改动：
  - 列表区补充 `content-visibility` / `contain-intrinsic-size`（适用区域）。
  - 高频图片补充 `loading="lazy"`、`decoding="async"`。
  - `Home` 卡片渲染使用 `useMemo`，减少无关状态变化导致的全量重建。
  - `Services` 中排序与缺图/缺评分计算改为 `useMemo`。
  - `Deals` 仅对“确实缺图”的店铺请求店铺图片，减少冗余网络调用。
- 效果：
  - 降低滚动页面渲染抖动与主线程压力。
  - 减少重复网络请求和不必要计算。

## 三、构建验证
- 命令：`cd frontend && npm run build`
- 结果：通过（无构建报错）。
- 说明：
  - 优化后产物由“大单包”调整为多 chunk 按路由分发。
  - 主入口包体明显下降（其余页面在访问时按需加载）。

## 四、风险与兼容性
- 未新增/修改后端 API 协议，业务入参与返回结构保持不变。
- GET 缓存默认 TTL 为短缓存（10s），写请求后会主动清理，降低数据一致性风险。
- 对强实时场景可在调用处传 `skipCache: true`。

## 五、后续建议
- 在 Vite 配置中增加 `manualChunks`，继续压缩首屏关键 chunk。
- 对超长列表（如预约历史、收藏列表）可进一步接入虚拟列表（窗口化渲染）。
- 为请求层补充命中率日志（dev only），便于观察缓存收益。

